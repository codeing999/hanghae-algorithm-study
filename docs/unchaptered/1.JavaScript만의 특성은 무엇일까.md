# JavaScript 만의 특성은 무엇일까?

다음의 내용을 알고 설명할 수 있다.

- 느슨한 타입(loosely typed)의 동적(dynamic) 언어
    - 느슨한 타입
    - 동적 언어
- JavaScript 형변환
    - 편리한 사례
    - 위험한 사례
- ==, ===
    - ==, 별로에요
    - ===, 좋습니다
- 느슨한 타입의 동적 언어의 문제점과 보완점
    - 문제점
    - 보완점
- undefined와 null의 미세한 차이들을 비교해보세요.

<hr>

## 느슨한 타입의 동적 언어

### 느슨한 타입

JavaScript 는 `느슨한 타입` 의 언어입니다.

이 말은, 하나의 변수에 형태가 다른 값을 넣을 수 있음을 의미합니다.

다수의 프로그래밍 언어가 `엄격한 타입` 을 지향하는 것과는 다른 모습입니다.

```javascript
var name = 'unchaptered';
name = 23;
name = true;
```

### 동적 언어, 그리고 정적 언어

JavaScript 는 동적 언어입니다.

즉, 실행 시점에 그 함수를 판별합니다.

다수의 프로그래밍 언어가 `정적 언어` 인 것과는 다른 모습입니다.

> 동적 언어와 정적 언어에 대하여...
>
> 더 정확한 표현으로는 `Interpreter 언어` 와 `Compile 언어` 입니다.
>
> 정적 언어로 유명한 `Java` , `C` 계열의 언어들은 최초 실행 시점에 모든 파일을 읽고 컴파일(변환) 작업을 진행하여 성능을 끌어올리게 됩니다.
>
> 하지만 동적 언어인 `JavaScript` 와 같은 언어는 각 함수의 호출 시점에 즉시 실행합니다.

<hr>

## JavaScript 의 형변환

JavaScript 에서 형변환은 `매우 자유롭게` 진행됩니다.

이러한 자유로움이 편리함과 위험함을 동시에 만들어냅니다.

<hr>

### 편리한 사례

`string` 타입인 숫자를 `number` 타입으로 변환하기

`문자열` 타입 안에 순수한 숫자가 담겨있을 때, + 연산자를 통해서 숫자로 바꿀 수 있습니다.

```javascript
const number_string = '1';
const number = +number_string;
```

### 위험한 사례

Boolean 타입은 명시적으로는 `true` `false` 이지만, 암묵적으로는 더욱 많이 존재합니다.

간단한 예시로는 0과 1이 각각 false 와 true 로 해석됩니다.

위험한 사례는 최근에 있었던 [[Issue] Boolean 을 이용한 조건문 분기의 위험성](
https://github.com/unchaptered/algorithm/issues/5) 을 차용하였습니다.

> 자세한 내용은 unchaptered/algorithm 레포지토리의 해당 이슈를 참고해주세요.

<hr>

## == 와 === 의 차이

### ==, 별로에요

== 는 그 값만을 비교합니다.

즉, '1' 과 1은 같습니다.

따라서 매우 위험하며 권장되지 않습니다.

### ===, 좋습니다

=== 는 그 값과 타입을 비교합니다.

즉, '1' 과 1은 다릅니다.

<hr>

## 느슨한 타입의 동적 언어의 문제점과 보완점

### 문제점

타입 및 값의 범위에 대한 안정성이 매우 낮습니다.

따라서 복잡한 서비스 로직에서 알 수 없는 에러가 발생할 수 있습니다.

### 보완점

따라서 Joi 와 같은 유효성 검사 라이브러리를 통해서 `유효성 검사 파이프 라인`을 만드는 것으로 해당 문제를 해결할 수 있습니다.

<br>

## undefined 와 null 의 차이점

undefined 는 변수에 값을 할당하지 않은 상태입니다.
그에 반해 null 은 직관적으로 프로레스의 실패를 의미하는 값으로 사용될 수 있습니다.

따라서 어떠한 프로세스 처리 이후 X 의 값을 반환하는 함수가 있다면, 실패했을 때에는 null 을 리턴해야 합니다.

> null is reccomended more than undefined

공식 문서 및 다양한 도서에서 이를 권장하고 있으며, 실제로 ES5 이후에 나온 다양한 문법은 undefined 와 null 에 따라서 엄격히 이를 구분 짓고 있습니다.

그 예시로 `구조분해할당` 에서의 기본값 부여는 undefined 에서는 작동하지만 null 에서는 작동하지 않습니다.