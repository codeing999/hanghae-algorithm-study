[< 뒤로가기](./READEMD.md)

## 그리디

### 그리디 알고리즘이란?

미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법입니다.

별도의 풀이법이 존재하는 것이 아니라, 

<hr>

## 분석 : 큰 수 만들기

- [프로그래머스 > 코딩테스트 연습 > 이분 탐색 > 입국심수](https://school.programmers.co.kr/learn/courses/30/lessons/42883)

문자열 형태로 제공되는 숫자 number 는 2 자리 이상 1_000_000 자리 이하인 숫자입니다.

이 숫자에서 k 개 만큼의 자리수를 제거하였을 때, 가장 큰 수를 골라주세요.

### 풀이 방향성 결정

만약 이 문제에 `그리디 알고리즘` 이라는 카테고리가 없었다고 생각하고 문제 풀이 방향을 고민해보았습니다.

가장 큰 수를 찾기 위해서는 모든 경우의 수를 찾고 해당 방법을 찾아야 했습니다.

하지만, 숫자의 길이가 너무 크기 때문에 모든 경우의 수의 집합을 계산하는 것은 비효율 적임이라고 느껴졌습니다.

따라서, 매 시점에서의 `일정한 조건` 을 만족하는 최적 결정을 해야지 문제를 해결할 수 있을 것이라고 생각했습니다.

## 풀이 : 큰 수 만들기

프로그래머스 2레벨 문제였습니다.

수의 체계 상, 가장 큰 수는 첫 자리수 가 가장 큰 수입니다.

따라서, stack 배열을 만들고 해당 배열의 `마지막값` 과 삭제 결정을 하는 시점의 `현재값` 을 비교하여 삭제 결정을 해주어야 합니다.

다만, `55555`와 같이 모든 자리수의 값이 같은 경우가 있기 때문에, 최종적으로 해당 부분을 확인해주어야 할 것 같습니다.

### 풀이법 1

- 결과 : 모든 테스트 케이스를 통과했습니다.

```javascript
function solution(number, k) {
    
    let stack = [];
    
    for (let i = 0 ; i < number.length;i++) {
        
        let nowValue = number[i];
        
        // 마지막 인자 가 현재 값보다 작으면, 마지막 인자를 배고 현재값을 넣습니다.
        // 마지막 인자 가 현재 값보다 크면, 마지막 인자 뒤에 현재값을 더합니다.
        while (k > 0 && stack[stack.length-1] < nowValue) {
            stack.pop();
            k--;
        }
        
        stack.push(nowValue);
        
    }
    
    // "55555", 3 과 같이 주어지는 경우에는 현재 stack 안에 "55555" 가 담기게 됩니다.
    // 따라서,  다음의 길이를 제거해주어야 합니다.
    //  stack 길이 - 추출할 길이 ~ 최대 k개 까지...
    stack.splice(stack.length - k, k);
    
    return stack.join("");
    
}

```
